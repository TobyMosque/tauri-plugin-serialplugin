if("__TAURI__"in window){var __TAURI_PLUGIN_SERIALPLUGIN__=function(t){"use strict";function e(t,e=!1){return window.__TAURI_INTERNALS__.transformCallback(t,e)}async function i(t,e={},i){return window.__TAURI_INTERNALS__.invoke(t,e,i)}var s;async function r(t,s,r){const n={kind:"Any"};return i("plugin:event|listen",{event:t,target:n,handler:e(s)}).then((e=>async()=>async function(t,e){await i("plugin:event|unlisten",{event:t,eventId:e})}(t,e)))}"function"==typeof SuppressedError&&SuppressedError,function(t){t.WINDOW_RESIZED="tauri://resize",t.WINDOW_MOVED="tauri://move",t.WINDOW_CLOSE_REQUESTED="tauri://close-requested",t.WINDOW_DESTROYED="tauri://destroyed",t.WINDOW_FOCUS="tauri://focus",t.WINDOW_BLUR="tauri://blur",t.WINDOW_SCALE_FACTOR_CHANGED="tauri://scale-change",t.WINDOW_THEME_CHANGED="tauri://theme-changed",t.WINDOW_CREATED="tauri://window-created",t.WEBVIEW_CREATED="tauri://webview-created",t.DRAG_ENTER="tauri://drag-enter",t.DRAG_OVER="tauri://drag-over",t.DRAG_DROP="tauri://drag-drop",t.DRAG_LEAVE="tauri://drag-leave"}(s||(s={}));let n={},a={};setInterval((()=>{console.log("check test listeners");for(let t in a)console.log("send test to "+t),a[t]("random")}),1e3);return t.SerialPort=class{constructor(t){this.is_test=!1,this.isOpen=!1,this.encoding=t.encoding||"utf-8",this.options={path:t.path,baudRate:t.baudRate,dataBits:t.dataBits||8,flowControl:t.flowControl||null,parity:t.parity||null,stopBits:t.stopBits||2,timeout:t.timeout||200},this.size=t.size||1024,this.is_test=t.is_test||!1}static async available_ports(){try{const t=await i("plugin:serialplugin|available_ports");for(const e in n)t[e]={manufacturer:"tester",pid:"tester",product:"tester",serial_number:"tester",type:"USB",vid:"tester"};return Promise.resolve(t)}catch(t){return Promise.reject(t)}}static async forceClose(t){return n[t]?(delete n[t],Promise.resolve()):await i("plugin:serialplugin|force_close",{path:t})}static async closeAll(){return n={},await i("plugin:serialplugin|close_all")}async cancelListen(){try{return void(this.unListen&&(this.unListen(),this.unListen=void 0))}catch(t){return Promise.reject("Failed to cancel serial monitoring: "+t)}}async cancelRead(){if(this.is_test)return Promise.resolve();try{return await i("plugin:serialplugin|cancel_read",{path:this.options.path})}catch(t){return Promise.reject(t)}}async change(t){try{let e=!1;return this.isOpen&&(e=!0,await this.close()),t.path&&(this.options.path=t.path),t.baudRate&&(this.options.baudRate=t.baudRate),e&&await this.open(),Promise.resolve()}catch(t){return Promise.reject(t)}}async close(){try{if(!this.isOpen)return;let t;return await this.cancelRead(),this.is_test||(t=await i("plugin:serialplugin|close",{path:this.options.path})),await this.cancelListen(),this.isOpen=!1,t}catch(t){return Promise.reject(t)}}async disconnected(t){let e=this.options.path?.toString().replace(/\.+/,""),i=`plugin-serialport-disconnected-${e}`;console.log("listen event: "+i);let s=await r(i,(()=>{try{t(),s(),s=void 0}catch(t){console.error(t)}}))}async listen(t,e=!0){try{await this.cancelListen();let i=this.options.path?.toString().replace(/\.+/,""),s=`plugin-serialport-read-${i}`;return console.log("listen event: "+s),this.is_test?(console.log("add test event: "+this.options.path,t),a[this.options.path]=t,this.unListen=()=>{delete a[this.options.path]},Promise.resolve()):void(this.unListen=await r(s,(({payload:i})=>{try{if(e){const e=new TextDecoder(this.encoding).decode(new Uint8Array(i.data));t(e)}else t(new Uint8Array(i.data))}catch(t){console.error(t)}})))}catch(t){return Promise.reject("Failed to monitor serial port data: "+t)}}async open(){try{if(!this.options.path)return Promise.reject("path Can not be empty!");if(!this.options.baudRate)return Promise.reject("baudRate Can not be empty!");if(this.isOpen)return;let t;return this.is_test?n[this.options.path]=this:t=await i("plugin:serialplugin|open",{path:this.options.path,baudRate:this.options.baudRate,dataBits:this.options.dataBits,flowControl:this.options.flowControl,parity:this.options.parity,stopBits:this.options.stopBits,timeout:this.options.timeout}),this.isOpen=!0,this.disconnected((()=>{this.isOpen=!1})).catch((t=>console.error(t))),Promise.resolve(t)}catch(t){return Promise.reject(t)}}async read(t){try{if(this.is_test){const t="";return a[this.options.path]&&a[this.options.path](t),Promise.resolve()}return await i("plugin:serialplugin|read",{path:this.options.path,timeout:t?.timeout||this.options.timeout,size:t?.size||this.size})}catch(t){return Promise.reject(t)}}async setBaudRate(t){try{let e=!1;return this.isOpen&&(e=!0,await this.close()),this.options.baudRate=t,e&&await this.open(),Promise.resolve()}catch(t){return Promise.reject(t)}}async setPath(t){try{let e=!1;return this.isOpen&&(e=!0,await this.close()),this.options.path=t,e&&await this.open(),Promise.resolve()}catch(t){return Promise.reject(t)}}async write(t){try{return this.isOpen?this.is_test?Promise.resolve(2):await i("plugin:serialplugin|write",{value:t,path:this.options.path}):Promise.reject(`serial port ${this.options.path} not opened!`)}catch(t){return Promise.reject(t)}}async writeBinary(t){try{return this.isOpen?t instanceof Uint8Array||t instanceof Array?this.is_test?Promise.resolve(2):await i("plugin:serialplugin|write_binary",{value:Array.from(t),path:this.options.path}):Promise.reject("value Argument type error! Expected type: string, Uint8Array, number[]"):Promise.reject(`serial port ${this.options.path} not opened!`)}catch(t){return Promise.reject(t)}}},t}({});Object.defineProperty(window.__TAURI__,"serialplugin",{value:__TAURI_PLUGIN_SERIALPLUGIN__})}
